"Response ID","Date submitted","Last page","Start language","Seed","IP address","Referrer URL","    If everything is clear, please continue. ","Ignoring the specific values in input, what is the valid ASCII value range of characters that output can contain after the function returned?","Which input characters can potentially affect output[0]? Use this example to explain how the dependency works in general (for output[n])?","What is the maximum number of times the function foo is invoked during program execution? Which values can the argument of foo have if the function is called? Explain why.","Under the assumption that each character in the input contains only printable ASCII characters (ASCII codes 33 to 126), does the function always terminate? Explain why.","    If everything is clear, please continue. ","Ignoring the specific values in input, what is the valid ASCII value range of characters that output can contain after the function returned 0?","Assuming the function was executed with input_len=L, how many characters are written to output? output_len is no valid answer.","Which input characters can potentially affect output[0]? Use this example to explain how the dependency works in general (for output[n])?","Under what conditions involving input and input_len is the character 'X' printed? Additionally, what is the maximum number of times 'X' can be printed? Explain why.","Total time","Group time: Sample 1A","Question time: S1Acode","Question time: S1Aq1","Question time: S1Aq2","Question time: S1Aq3","Question time: S1Aq4","Group time: Sample 2A","Question time: S2Acode","Question time: S2Aq1","Question time: S2Aq2","Question time: S2Aq3","Question time: S2Aq4"
"1","1980-01-01 00:00:00","10","en","1943182955","129.233.182.0","https://limesurvey.ndrs.ovh/","","By looking at the last few lines one can see the possible ranges:
- From 80 (inclusive) to 123 (exclusive)
- From 62 (inclusive) to 101 (exclusive)

","output[0] is potentially influenced by input[(0 + input_len / 2) % input_len] , input[(0 + 0)  % input_len], input[(0 + 1)  % input_len] and input[(0 + 2)  % input_len].

output[n] is potentially influenced by input[(n + input_len / 2) % input_len] , input[(n + 0)  % input_len], input[(n + 1)  % input_len] and input[(n + 2)  % input_len].","The maximum number of times the funtion foo is invoked is input_len * 3. For each for iteration possible 3 times in the while.

The values passed to foo need <= 150 because of the while condition.","The function would always terminate. The only loop which could potentially loop forever is the while when always going to the continue statement. However the condition var_5 < 60 will eventuelly reach false, as var_5 is increasing with each iteration.","","Possible ranges include:
- From 48 (inclusive) to (74 + 48) (exclusive)
- Exactly 35","9 characters. The while loop is only exited when reaching the single break statement, which is guarded by var_1 >= 8","output[0] is potentially affected by all input[i * output_len] where i * output_len <= input_len
output[n] is potentially affected by all input[n + i * output_len] where n + i * output_len < input_len","X is printed when input_len < 7
The maximum amount of times X can be printed is 8 - 1 = 7 because input_len needs to be atleast 1 and x is only printed when var_1 >= input_length.","3290.22",,"31.52","708.62","281.9","146.78","444.8",,"8.45","312.66","433.05","728.59","193.85"
"2","1980-01-01 00:00:00","10","en","1535114576","129.233.182.0","https://limesurvey.ndrs.ovh/","","Assumption: it is possible that I can construct arbitrary input such that the large while loop just ""scrambles"" the output, but doesn't limit the value range.  The important part is in lines 25-30: cval is first limited to 80 + cval % 43 => range [80, 122]. When i is even, we decrease the lower bound -> cval % 39 + 62.

The answer should be [62, 122]","time exceeded","time exceeded","time exceeded","","[30, 122]. LABEL_3 limits range to [48, 122], smallest case for else branche in 31 is 101 -> 101 /2 - 15 - 5 = 30 = lower bound  ","time exceeded","time exceeded","time exceeded","3693.3",,"23.51","1753.45","68.5","13.19","8.1",,"4.45","1237.02","577.73","3.6","3.75"
"3","1980-01-01 00:00:00","10","en","1246377447","129.233.182.0","https://limesurvey.ndrs.ovh/","","I don't know","output[n] is affected by var_3 which may be affected by input[var1] (line 20) if var_5 is < 60.  This is the case if var_3 / 3 = input[(input_len+var_1)/2]  / 3 < 60 for var_1 < input_len. 
Since no time is left i would say, that output may be affected by input[0] to input[input_len/2-1]","if var_5 is always larger 60 foo is invoked  2 times for each for loop iteration because of the break if var_4 > 2 and var_4 increasing each while loop iteration. range from 50/3 to 85","no time left","","96-250","I don't know"," output[n] may be affected by input[var_1]=input[*] and var_5=input[var_6]=input[*]","maximum of 8 (var_1 < 8) ","3669.98",,"40.18","566.22","851.33","351.89","51",,"6.55","555.89","688.92","284.36","273.64"
"4","1980-01-01 00:00:00","10","en","1279427854","129.233.182.0","https://limesurvey.ndrs.ovh/","","output can contain 62 - 122","I don't know","It can be invoked up to (max(input_len) - 1)) * 3 times, after every call of foo, var_4 is incremented by one (@19). If it reaches 3, the while loop (@7) breaks (@15f). var_4 is initialized with 0 (@5) on each iteration of the for loop (@3). The for-loop terminates once i >= input_len. 
var_5 (the argument of function call foo) is >= 60 (because smaller values lead to continue, which checks the value of var_5 again) and <= 150 (if it is larger than 150, the while loop ends)","Since input_len is a signed integer, just as the counter i (@3), it will terminate latest once i reaches signed_int_max (assuming input_len was set to signed_int_max, too)","","35, 48 - 122","As far as I understood the question, it is not about, how many times values of output[i] are changed, but what is the final ""string length"" of output? Then my answer is 8 at most, 1 at least","odd ascii values are changed to the next even value. Even ascii values are ""halfed"" (divided by 2)
Ok, I still don't understand this. Sorry","req input_len >= 1
req output_len > 0

7 times if input_len == 1
but... ok I am def missing something","3348.28",,"23.64","235.44","245.72","787.02","207.62",,"7.45","579.05","351.3","286.57","624.47"
"5","1980-01-01 00:00:00","10","en","998533600","129.233.182.0","https://limesurvey.ndrs.ovh/index.php/","","var3 = input[...]
var3 = var3 + input[...]
var3 = var3 - input[var1]
var3 = var3 % 43 + 80
""var3"" to ""var3 % 39 + 62""

answer: 1-122 (42+80)","output[0]: affecting input characters: 0 (line 20), 1, 2 (from loop line 10), middle character (input_len/2, line 2+4)

output[n]: input[n], input[n+1], input[n+2], input[input_len/2+n]","maximum number of times: input_len * 3

values of foo argument: 0 - 150","No, because if the input is only ascii 33, var_5 should always be 11 (var_3 / 3 and var_3 is always the value of a character in input) and thus the while loop is never quit. Also, if I understood it correctly now, the answer to the last questions should be ""infinitely"" I guess.","","-5 to 121 (73+48)","we break the while loop if  var_1 is >= 8, thus it should always be 9?","output[0] is affected by input[0]

generally, output[n] is affected by input[var_6], while var_6 is either n or the character in the middle of the input (?)","I do not know.","3279.48",,"28.1","869.31","349.57","251.87","359.21",,"18.3","445.97","262.32","358.24","336.59"
"6","1980-01-01 00:00:00","10","en","170588211","129.233.182.0","https://limesurvey.ndrs.ovh/index.php/","","Assuming the input len>0, the valid values are in the interval [62, 122]","The value of output[n] depends on n, n+1, n+2 and input_len/2+n. Each value modulo input_len","Maximum number is 2 because of the if statement in line 15.
Input values are within [60,150]. Values smaller 60 will be prevented by the continue statement in the if statement in line 8 and values larger 150 are prevented by the while loop
","Continue with next sample due to time","","The value range is [48,121] and 35.","If L<1 -> 0
If L>1 -> 8","I guess for output[n] only input[n] is relevant","Input_len has to be lager than 1.
It is printed 8-Input_len+1 times.
It can not be printed more than 8 times.
Time is up","4252.86",,"33","828.07","813.87","601.18","15.28",,"7.96","510.81","488.86","445.81","508.02"
"7","1980-01-01 00:00:00","10","en","1625172683","129.233.182.0","https://limesurvey.ndrs.ovh/","","Wegen Zeile 23 kann der output char höchstens 42+80 = 122 sein, also 'z'. Ist input komplett 0, bleibt current_char bis 23 0. 0 % 43 + 80 = 80. Wenn wir dann in zeile 25 kommen ist 80 % 39 + 62 = 64. Also ist das intervall [64:122].","output[n] hängt ab von:
input[n], input[n+1%len(input)], input[n+2%len(input)] wegen zeile 10 (und input[n] nochmal in Zeile 20)
input[len(input)/2+n % len(input)] , da dieser char in Zeile 4 zur initialisierung genommen wird","Zwei mal pro Character in input, da die innere schleife abgebrochen wird wenn der index > 2 ist (Zeile 15-17), also len(input) * 2 
Der foo call kann nur erreicht werden, wenn var_5 <60 ist, da sonst durch das continue die schleife neu gestartet wird oder durch die condition der while-schleife abgebrochen wird. Also kann foo werte zwischen 0 und 59 erhalten.","Zur frage davor: Foo kann nur erreicht werden wenn die input var zwischen 60 und 150 ist - hab die ungleichung im if falsch herum gelesen

Ja die funktion terminiert: wenn in der innersten schleife var_5 zu klein ist wächst es kontinuierlich, selbst wenn input mit den kleinst möglichen werten gefüllt ist. die schleife darüber terminiert nach spätesetens zwei durchläufen wegen dem check danach. damit läuft die funktion bis zum ende","","Zeile 32 setzt den char auf output[var_1] + current_char % 74 + 48, also theoretisch minimal 48. 
Wenn der char >= 100 ist, sagen wir 256 als maximum, wirds halbiert (128) , dann 15 abgezogen (113), dann nochmal 5 abgezogen (108). Also [48:108]","Ich glaube höchstens 8? weil nur in dem if block in der schleife nach output geschrieben wird, und sobald var_1 8 oder größer wird wird gebreakt, und sonst zurück gesprungen. var_1 wird auch nur auf 0 gesetzt und inkrementiert, also ich glaube es sind immer 8? Aber kein plan","Die ersten 8. Ich glaube wie in der letzten Frage beschrieben dass var_1 nur werte von 0-7 annehmen kann, da es nur inkrementiert wird und wenn es 8 erreicht ist die funktion fertig. Der komische if-block in 12-20 macht glaub ich nur den wrap-around wenn der index > input_len ist.","X wird geprintet, wenn der aktuelle index, der das input/output buffer durchläuft, >= input_len ist. Angenommen das input buffer hat mindestens einen eintrag (bei 0 würde es einen segfault geben) und input_len ist tatächlich die länge von input, gäb es bei einer länge von 1 denke ich 6 mal ein X. Die ersten zwei durchläufe gehen normal, dann ist der index größer als input_len, und es wird in jeder neuen runde ein x ausgegeben. Da ich ja denke, dass es immer genau 8 runden insgesamt gibt, müssten somit 6 X rauskommen ","2978.03",,"12.16","644.64","348.55","329.89","335.07",,"4.43","515.29","333.1","204.05","250.85"
"8","1980-01-01 00:00:00","10","en","19875522","37.201.181.0","https://limesurvey.ndrs.ovh/","","The valid ASCII range is between 80  and 122 ","The output[0] depends on the character that is in the middle of the string. Hence the input_len/2
There are two indices going over the input string. The first is going from the first character to the last, which decides which character is modified. 
The other index starts in the middle of the string and loops around once and this input character influences the output.","The function foo() is called a maximum of 3 times. Because var_4 decides when we break out of the loop.
The argument of function foo() needs to be smaller than 150 and bigger than 60","At some point the var_3 will always become big enough to be higher than 60 so there cannot be an endless loop.
","","The range is 48 - 122","The answer should be 8 because the only way we can exit the while(true) loop is by reaching the break. The break can only be reached if we have a number greater equal 8 for var_1 the index of the output. ","output[0] the index is coming from var_1 which is incremented in the loop and is not modified in any other way. 
Therefore, I would argue that only input[0] influences output[0]. So there is a n to n relationship. If the input length is smaller than 8 then the index for the input list is looped.","X is printed whenever the input_len variable is smaller than 8 because then the index from the output is generated needs to loop.
So the X is printed abs(8 - input_len) times. This means for an input_len of 0 the maximum number is 8.
However, in a real-world scenario an input_len of 0 does not make a lot of sense because then there would be no defined input.
Therefore, the number should be above 0, which would mean that the maximum number of times is 7.","3674.39",,"30.76","444.56","411.41","417.71","510.68",,"128","465.22","431.38","556.37","278.3"
"9","1980-01-01 00:00:00","10","en","193716672","129.233.182.0","https://limesurvey.ndrs.ovh/","","0-100","Correction of the previous Question: the value range is 0 - 122. I forgot the else case. 

Answer for this question: I am not sure. var_3 is set to ""var_3 % 43 + 80"". Thus, each position of the output is set either to 0-122 or 0-100 (if it is an number which can be divided by 2). Which value var_3 has, depends on the first half of the input i guess, because it is always set to input[var_2 % input_len], which is maximum the half of the input_len. 

","There is no time left","there is not time left, sorry!","","Output can contain characters in the value range 48-121 or the value 35 (#).","There is no time left, sorry!","There is no time left, sorry!","There is no time left, sorry!","3993.8",,"41.36","628.7","1446.19","28.25","11.08",,"15.21","1204.42","609.45","3.99","5.15"
"10","1980-01-01 00:00:00","10","en","1029696977","129.233.182.0","https://limesurvey.ndrs.ovh/","","It can contain values between 62 and 122. 
Every second entry starting at index 0 (2,4,6,...) can only cotanin values between 62 and 100 and all entries for odd indices can contain values between 80 and 122.","The output[0] is dependent on the variable var_3, which is directly influenced by change of input[0]. Additionally it is influenced by the next three entries of the input (see line 10) so input[1], input[2], and input[3] in case our input in > 4. 
Otherwise we use modulo and access the first elements again.","It can get executed a maximum of input_len*55 times. var_5 so the input of foo can take any value which is a multiple of 3 as well as 2 due to line 12 until var_5 is less than 60 (0,6,12,18,...).
Between 60 and 149 it needs to be an multiple of 2 only to line 21 (60,62,64,...).
","No, since var_5 could stay dependent on the input always between 60 and 149 triggering an endless loop. Since if all entrioes are 126; var_5 would be larger than 60. ","","The range is 0-122. ","Output length is must be equal to the input len L","output[0] can be affected by input[var_6] for. Since in the first iteration var_6 = var_1 = 0 it is smaller thzan the input_len skipping the if in line 12. 
Therefore var_6 is 0 and therefore output[0] is only affected by input[0]. (since we also only increase var_1 so the indice used for the output we never get to write output[0] again.","8 times since, var_1 gets increased for each input and can therefore jump to LABEL_1. 
In the first entrance in the function the if condition in line 12 is not met. So only maximum of 8 times.","2909.96",,"23.73","295.21","373.6","488.37","488",,"3.87","286.1","463.16","256.06","231.86"
"11","1980-01-01 00:00:00","10","en","758072677","129.233.182.0","https://limesurvey.ndrs.ovh/index.php/","","62 -> 122","all","Erklärung zur letzeten Frage: var_5 ist immer < 150, da var_3 aus input kommt und max char 255 / 3 = 85, loop wird immer ausgeführt, entweder im `var_5 < 60` block oder am Ende der Schleife wird var_3 (upper_half_char) verändert. Also keine immer.

Diese Frage:
3 da var_4 > 2 den while loop breakt und die Abfrage vor foo() geschieht.","Der for loop läuft input_len mal, terminiert also. Der innere while loop läuft solange wie var_5 <= 150, da var_5 signed int ist, könnte es kleiner 0 werden und villeicht den loop breaken, wenn das <= als unsigned vergleicht oder wenn var_5 überläuft und auch als signed int positiv wird.","","35, 48 -> 121","letzte Frage: 35 wohl doch nicht da nur ein ungerader Wert den == 40 Pfad nimmt.

diese Frage: keine Ahnung","ka","ka","3820.64",,"33.07","469.48","661.56","438.87","384.17",,"11.33","630.59","866.01","319.86","5.7"
