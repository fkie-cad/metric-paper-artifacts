group,ID,S1q1,Solution: even: 62 (“>”) – 100 (“d”) and odd 80 (“P”) – 122 (“z”),S1q2,"Solution: out[n] depends on input[(len/2 + n) % len] and depending on the value of input[(len/2 + n) % len] also on input[n], input[(n+1) % input_len], and input[(n+2) % input_len]",S1q3,Solution: 3*input_len and var_5 is between 60 and 150,S1q4,"Solution: Yes: while-loop: if executed at most 2 times in a row, var_4 increased at most 3 times → <=12 iterations of the while-loop",S2q1,Solution: 35 = “#” or between 48 = “0” and 121 = “y”,S2q2,Solution: 8 characters,S2q3,"Solution: out[0] depends on input[k*8] with 0<=k<length/8 if 0 < length

In general: out[n] depends on input[n+8k] with 0<=k<(length-n)/8 if n < length
Otherwise: out[n] depends on input[x + 8k] with x=n % (2*length) or x = n % (2*length) – length",S2q4,Solution: only if input_len < 8; thus at most 7 times if input_len = 1.
A,1,"By looking at the last few lines one can see the possible ranges:
- From 80 (inclusive) to 123 (exclusive)
- From 62 (inclusive) to 101 (exclusive)

",1,"output[0] is potentially influenced by input[(0 + input_len / 2) % input_len] , input[(0 + 0)  % input_len], input[(0 + 1)  % input_len] and input[(0 + 2)  % input_len].

output[n] is potentially influenced by input[(n + input_len / 2) % input_len] , input[(n + 0)  % input_len], input[(n + 1)  % input_len] and input[(n + 2)  % input_len].",1,"The maximum number of times the funtion foo is invoked is input_len * 3. For each for iteration possible 3 times in the while.

The values passed to foo need <= 150 because of the while condition.",0.75,"The function would always terminate. The only loop which could potentially loop forever is the while when always going to the continue statement. However the condition var_5 < 60 will eventuelly reach false, as var_5 is increasing with each iteration.",1,"Possible ranges include:
- From 48 (inclusive) to (74 + 48) (exclusive)
- Exactly 35",1,"9 characters. The while loop is only exited when reaching the single break statement, which is guarded by var_1 >= 8",1,"output[0] is potentially affected by all input[i * output_len] where i * output_len <= input_len
output[n] is potentially affected by all input[n + i * output_len] where n + i * output_len < input_len",0.9,"X is printed when input_len < 7
The maximum amount of times X can be printed is 8 - 1 = 7 because input_len needs to be atleast 1 and x is only printed when var_1 >= input_length.",1
A,2,"Assumption: it is possible that I can construct arbitrary input such that the large while loop just ""scrambles"" the output, but doesn't limit the value range.  The important part is in lines 25-30: cval is first limited to 80 + cval % 43 => range [80, 122]. When i is even, we decrease the lower bound -> cval % 39 + 62.

The answer should be [62, 122]",1,time exceeded,None,time exceeded,None,time exceeded,None,"[30, 122]. LABEL_3 limits range to [48, 122], smallest case for else branche in 31 is 101 -> 101 /2 - 15 - 5 = 30 = lower bound  ",0.25,time exceeded,None,time exceeded,None,time exceeded,None
A,3,I don't know,0,"output[n] is affected by var_3 which may be affected by input[var1] (line 20) if var_5 is < 60.  This is the case if var_3 / 3 = input[(input_len+var_1)/2]  / 3 < 60 for var_1 < input_len. 
Since no time is left i would say, that output may be affected by input[0] to input[input_len/2-1]",0.125,if var_5 is always larger 60 foo is invoked  2 times for each for loop iteration because of the break if var_4 > 2 and var_4 increasing each while loop iteration. range from 50/3 to 85,0.75,no time left,None,96-250,0,I don't know,0, output[n] may be affected by input[var_1]=input[*] and var_5=input[var_6]=input[*],0,maximum of 8 (var_1 < 8) ,0.5
A,4,output can contain 62 - 122,1,I don't know,0,"It can be invoked up to (max(input_len) - 1)) * 3 times, after every call of foo, var_4 is incremented by one (@19). If it reaches 3, the while loop (@7) breaks (@15f). var_4 is initialized with 0 (@5) on each iteration of the for loop (@3). The for-loop terminates once i >= input_len. 
var_5 (the argument of function call foo) is >= 60 (because smaller values lead to continue, which checks the value of var_5 again) and <= 150 (if it is larger than 150, the while loop ends)",1,"Since input_len is a signed integer, just as the counter i (@3), it will terminate latest once i reaches signed_int_max (assuming input_len was set to signed_int_max, too)",0.3,"35, 48 - 122",1,"As far as I understood the question, it is not about, how many times values of output[i] are changed, but what is the final ""string length"" of output? Then my answer is 8 at most, 1 at least",0.5,"odd ascii values are changed to the next even value. Even ascii values are ""halfed"" (divided by 2)
Ok, I still don't understand this. Sorry",0,"req input_len >= 1
req output_len > 0

7 times if input_len == 1
but... ok I am def missing something",0.5
A,5,"var3 = input[...]
var3 = var3 + input[...]
var3 = var3 - input[var1]
var3 = var3 % 43 + 80
""var3"" to ""var3 % 39 + 62""

answer: 1-122 (42+80)",0.9,"output[0]: affecting input characters: 0 (line 20), 1, 2 (from loop line 10), middle character (input_len/2, line 2+4)

output[n]: input[n], input[n+1], input[n+2], input[input_len/2+n]",1,"maximum number of times: input_len * 3

values of foo argument: 0 - 150",0.75,"No, because if the input is only ascii 33, var_5 should always be 11 (var_3 / 3 and var_3 is always the value of a character in input) and thus the while loop is never quit. Also, if I understood it correctly now, the answer to the last questions should be ""infinitely"" I guess.",0.3,-5 to 121 (73+48),0.25,"we break the while loop if  var_1 is >= 8, thus it should always be 9?",1,"output[0] is affected by input[0]

generally, output[n] is affected by input[var_6], while var_6 is either n or the character in the middle of the input (?)",0.2,I do not know.,0
A,6,"Assuming the input len>0, the valid values are in the interval [62, 122]",1,"The value of output[n] depends on n, n+1, n+2 and input_len/2+n. Each value modulo input_len",1,"Maximum number is 2 because of the if statement in line 15.
Input values are within [60,150]. Values smaller 60 will be prevented by the continue statement in the if statement in line 8 and values larger 150 are prevented by the while loop
",0.75,Continue with next sample due to time,None,"The value range is [48,121] and 35.",1,"If L<1 -> 0
If L>1 -> 8",1,I guess for output[n] only input[n] is relevant,0.2,"Input_len has to be lager than 1.
It is printed 8-Input_len+1 times.
It can not be printed more than 8 times.
Time is up",0.5
A,7,"Because of line 23, the output char can be at most 42+80 = 122, i.e. ‘z’. If input is completely 0, current_char remains 0 until line 23. 0 % 43 + 80 = 80. When we then reach line 25, 80 % 39 + 62 = 64. So the interval is [64:122].",1,"output[n] depends on:
input[n], input[n+1%len(input)], input[n+2%len(input)] because of line 10 (and input[n] again in line 20)
input[len(input)/2+n % len(input)] , because this char is used for initialization in line 4",1,"Twice per character in input, since the inner loop is terminated when the index is > 2 (lines 15-17), i.e. len(input) * 2
The foo call can only be reached if var_5 <60, because otherwise the loop is restarted by the continue or terminated by the condition of the while loop. So foo can receive values between 0 and 59.",1,"Regarding the previous question: Foo can only be reached if the input variable is between 60 and 150 – I read the inequality in the if statement the wrong way round.

Yes, the function terminates: if var_5 is too small in the innermost loop, it grows continuously, even if input is filled with the smallest possible values. The loop above terminates after at least two passes because of the check afterwards. This means that the function runs to the end.",1,"Line 32 sets the char to output[var_1] + current_char % 74 + 48, which is theoretically a minimum of 48.
If the char is >= 100, let's say 256 as the maximum, it is halved (128), then 15 is subtracted (113), then another 5 is subtracted (108). So [48:108]",0.25,"I think 8 at most? Because output is only written in the if block in the loop, and as soon as var_1 becomes 8 or greater, it breaks, and otherwise jumps back. var_1 is also only set to 0 and incremented, so I think it's always 8? But I'm not sure.",1,"The first 8. As described in the last question, I believe that var_1 can only take values from 0-7, since it is only incremented and when it reaches 8, the function is done. I think the strange if block in 12-20 only does the wrap-around when the index > input_len.",0,"X is printed when the current index passing through the input/output buffer is >= input_len. Assuming that the input buffer has at least one entry (if it were 0, there would be a segfault) and input_len is actually the length of input, I think there would be 6 Xs for a length of 1. The first two passes go normally, then the index is greater than input_len, and an x is output in each new round. Since I think there are always exactly 8 rounds in total, there should be 6 Xs. ",0.75
A,8,The valid ASCII range is between 80  and 122 ,0.5,"The output[0] depends on the character that is in the middle of the string. Hence the input_len/2
There are two indices going over the input string. The first is going from the first character to the last, which decides which character is modified. 
The other index starts in the middle of the string and loops around once and this input character influences the output.",0.125,"The function foo() is called a maximum of 3 times. Because var_4 decides when we break out of the loop.
The argument of function foo() needs to be smaller than 150 and bigger than 60",0.75,"At some point the var_3 will always become big enough to be higher than 60 so there cannot be an endless loop.
",1,The range is 48 - 122,0.5,The answer should be 8 because the only way we can exit the while(true) loop is by reaching the break. The break can only be reached if we have a number greater equal 8 for var_1 the index of the output. ,1,"output[0] the index is coming from var_1 which is incremented in the loop and is not modified in any other way. 
Therefore, I would argue that only input[0] influences output[0]. So there is a n to n relationship. If the input length is smaller than 8 then the index for the input list is looped.",0.2,"X is printed whenever the input_len variable is smaller than 8 because then the index from the output is generated needs to loop.
So the X is printed abs(8 - input_len) times. This means for an input_len of 0 the maximum number is 8.
However, in a real-world scenario an input_len of 0 does not make a lot of sense because then there would be no defined input.
Therefore, the number should be above 0, which would mean that the maximum number of times is 7.",1
A,9,0-100,0.5,"Correction of the previous Question: the value range is 0 - 122. I forgot the else case. 

Answer for this question: I am not sure. var_3 is set to ""var_3 % 43 + 80"". Thus, each position of the output is set either to 0-122 or 0-100 (if it is an number which can be divided by 2). Which value var_3 has, depends on the first half of the input i guess, because it is always set to input[var_2 % input_len], which is maximum the half of the input_len. 

",0,There is no time left,None,"there is not time left, sorry!",None,Output can contain characters in the value range 48-121 or the value 35 (#).,1,"There is no time left, sorry!",None,"There is no time left, sorry!",None,"There is no time left, sorry!",None
A,10,"It can contain values between 62 and 122. 
Every second entry starting at index 0 (2,4,6,...) can only cotanin values between 62 and 100 and all entries for odd indices can contain values between 80 and 122.",1,"The output[0] is dependent on the variable var_3, which is directly influenced by change of input[0]. Additionally it is influenced by the next three entries of the input (see line 10) so input[1], input[2], and input[3] in case our input in > 4. 
Otherwise we use modulo and access the first elements again.",0.375,"It can get executed a maximum of input_len*55 times. var_5 so the input of foo can take any value which is a multiple of 3 as well as 2 due to line 12 until var_5 is less than 60 (0,6,12,18,...).
Between 60 and 149 it needs to be an multiple of 2 only to line 21 (60,62,64,...).
",0.5,"No, since var_5 could stay dependent on the input always between 60 and 149 triggering an endless loop. Since if all entrioes are 126; var_5 would be larger than 60. ",0.3,The range is 0-122. ,0.25,Output length is must be equal to the input len L,0,"output[0] can be affected by input[var_6] for. Since in the first iteration var_6 = var_1 = 0 it is smaller thzan the input_len skipping the if in line 12. 
Therefore var_6 is 0 and therefore output[0] is only affected by input[0]. (since we also only increase var_1 so the indice used for the output we never get to write output[0] again.",0.1,"8 times since, var_1 gets increased for each input and can therefore jump to LABEL_1. 
In the first entrance in the function the if condition in line 12 is not met. So only maximum of 8 times.",0.75
A,11,62 -> 122,1,all,0,"Explanation of the last question: var_5 is always < 150, since var_3 comes from input and max char 255 / 3 = 85, loop is always executed, either in the `var_5 < 60` block or at the end of the loop var_3 (upper_half_char) is changed. So not always.

This question:
3 because var_4 > 2 breaks the while loop and the query occurs before foo().",0.5,"The for loop runs input_len times, thus terminating. The inner while loop runs as long as var_5 <= 150. Since var_5 is a signed int, it could become smaller than 0 and possibly break the loop if <= compares as unsigned or if var_5 overflows and also becomes positive as a signed int.",0.3,"35, 48 -> 121",0.5,"Last question: 35 probably not, since only an odd value takes the == 40 path.

This question: No idea.",0,no idea,None,no idea,None
B,1,"62 to 100 from first if branch, 80-122 from else branch, so 62-122 in total.",1,"The output offset is initially set on the ""middle"" (input_len / 2) of the input string, then walks forward in increments of 1, reset to 0 when reaching the end of the string due to the modulo operation (input[source_offset % input_len]). Thus, the char at input[input_len / 2] affects output[0]. Additionally, output_value += input[(output_offset + var_6) % input_len]; may affect output[0], which would be input[0] due to initialization.",0.125,"Due to the range check with >150 and <60, foo will always be called with a value between 60-150 (inclusively). Technically the range check can be executed 3 times per input char but I don't know if an input char sequence exists that will sufficiently often increase output_value to be within the target range for every input char.",1,"in a string only consisting of lowest values, there may be a risk that the lower range value check sends us into an infinite loop.",0,"output values should have the range [35-39, 41-121].",0.25,"Only loop_count_max_8 is used as an offset to write to output, loop_count_max_8 is only affected by loop_count_max_8++; and the loop should only exit on the while condition while (loop_count_max_8 < 8) with no break instructions, which suggests  output has a constant length of 8, if L>=1, 0 otherwise.",1,"output_len is never checked and influences how the while loop starting at line 27 processes input strings. with output_len=0 we may instantly enter an infinite loop, choosing 1 will result in all input chars contributing to var_5, which ultimately affects output[0]. The behavior and use of input chars per output char heavily depends on output_len.",0,"input has no influence on whether X is printed or not, only input_len and the current loop count. input_len has to be 1 or above to reach this part in the function. As the loop is iterated at most 8 times, the number of X printed should be (8 - input_len), maximum 7 times.",1
B,2,"if var_1 is even, output can range from 80 (""P"") to 80 + 43 = 123 (""{"") and if var_1 is even, output can range from 62 ("">"") to 62 + 39 = 101 (""e""). Combined, it is 62 ("">"") to 123 (""{"").",1,"var_5 = var_3 / 3 = (input[var_2 % input_len]) / 3 = (input[input_len / 2 % input_len]) / 3 = input[input_len] / 3 > 150 cannot occur for the first iteration and will go to Label 4, so var_3 is only affected from the middle of input (the char depends on whether the length is even or odd). 
In label 4 and 5, the first 3 characters from input can affect var_3.
Then var 1 and 2 are increased by 1, so the window that affects the output will shift forward.",0,"We reach label 6 only if var_5 is between 60 and 150. var_5 is only increased, never decreased. var_3 is increased by the byte value of individual characters in input. Byte values can range from 0 to 256 and var_5 = var_3 / 3. Time is over.",0.5,time is over.,None,"in the very specific case that we reach line 43, output will be 35 (""#""). Otherwise it will be between 74 (""J"") and 74 + 48 = 122 (""z"").",1,"if L = 0: 0. Otherwise, i starts at 0 and is always increased by 1 and the loop will continue until it reaches 8. Output is written to output[i], so it should have the length 8 (from index 0 to 7).",1,"output[i] depends on var_5 and var_5 depends on j. j depends on i (ranges from 0 to 7) and output_len (probably 8). Therefore, output[i] can be affected by input[i] and all x that satisfy i = x % output_len, so every output_len'th character in input.",0.9,"since j is set to i and i can range between 0 and 7, and the ""X"" is printed in line 13, it is only printed when input_len <= 7.
If input_len is 1, ""X"" will be printed every time j >= 1, so 7 times. This is the maximum number (because if input_len is larger, it will be printed fewer times)",1
B,3,"I would go by the out parameter, and resolve by going upwards.
var_1 % 2 makes always 0, so I take the if branch, because (var_1 % 2 == 0) results is TRUE.
but I have to resolve var3 upwards, which seems rather impossible. var3 is a char, and can overflow (for example in line 39). A uchar can have any value between 0 and 255.
however, 0 % 39 + 62 = 0. That makes one possible range.
1 % 39 makes 1. that would be make 63.
39 % 39 makes 0, that would make 62.
40 % 39 makes 1, that would make 63. 
41 % 39 would make 2, that would result in 64.
So I guess I'd have to find out what can result from this modulo operation, but I think I am out of time.",0,"Okay, if (var_1 % 2 == 0)  always evals to TRUE. 
It'  output[var_1] = var_3 % 39 + 62;

I try to resolve manually var_3 by going from bottom to top. That's going to be AWFUL.

Definitely input[0] is going to affect var_3:
var_3 -= input[var_1]; 

In the other case, too. 

Input length wasn't asked.

Concerning input, only input[0] affects output.",0.125,"I spend too much time even finding foo.
Then I saw var_5, I was thinking if var_5 could overflow... time over.",0,time over.,None,"I go to the bottom by output and resolve upwards, generally. 
However, there is some term xxx % 74 + 48. I don't know yet what xxx can assume as values. 
output[var_1] is output[0], any byte between 0 and 255 could be inside. var_5 = input[var_6] must be assumed as any byte between 0 and 255. There can be overflow, so at first, without looking at the rest, anything + anything also makes anything.

I do not know what ranges could result from x % 74 + 48.
x % 74 + 48 makes 0+48. 
x = 74 makes 0+48, too.
x = 73 makes 73+48.
x = 75 makes 1+48.

Probably no greater value than 73 can result by x, so the greatest value could possibly be 73+48=121.
The smallest value is 0+48, so 48.
Possibly ranges would be 48 - 121.",0.5,"If input_len L is less than 1, zero characters are written. ;-p
Also, f(var_6 >= input_len){ is always 0, except the first case that input_len is < 1, which we already had.

Anyway, aat line 36, output[0] = var_5 % 256;

One character is written here. (no matter the do/while loop).

Same in 43: output[0] -= 5;

One character is written. (If inputlen L > 1).
Otherwise no character is written at all.",0,"The first character (input[0]) only.
If I didn't oversee anything this questions was much too simple?",0.1,"I mentioned this already in task 1.
If input Length L is 0 (< 1), it returns directly. No X is printed.

0 >= 0 = TRUE, but was already taken, so no. Never comes here.
0 >= 1 = FALSE
0 >= anything = FALSE.

So the second term
if(var_6 >= input_len)
{
            printf(""X"");
}

can never happen at all.

I don't see how X can be printed at all!",0
B,4,"Either between 62 and 100, or 80 and 123 (not exclusively, per character)",1,"For output[0], it's (probably) input[0], [1], [2] and [input_len / 2]. For  output[n] it's input[0+n], [1+n], [2+n], [(input_len / 2) + n] (omitted the % input_len everywhere)",1,"Executed a maximum of input_len * 2 times. Limited by var_4 < 2, which is increased by 1 after every execution of foo() and only reset when we move on to the next character. It is only called with values between 60 and 150",1,"Function only terminates when we iterated over every char in output (out_index > input_len). out_index is only increased in LABEL_7, which is only ""called"" when:

a) var_5 > 150.
var_3 is the sum of at most three input characters, and since var_5 = var_3 / 3 and input characters are all <126, this path is never taken

b) Out of time ",0,"range should be
[48, 122], but 35 is also possible",1,"while(cur_index < 8), we'll always return when we leave this.
Per loop, we only write once to output (at the end), and then we increase cur_index. So unless im blind, we always write 8 characters in ouput?",1,"for out[0], its input[0] and then every output_len'th character in input. For out[n], it's... the same? var_6 is kept in bound by the stuff in lines 12-19, but since our cur_index is always <8, if we ever hit that check, we'll immediately exit the while loop later on (since our input_len is so small), so we'll only use out[n]",0.9,"X can be printed a maximum of 7 times - our outer loop runs 8 times, we have no jumps or anything, and X gets printed if our current index is >= the input length. This cant happen on the first loop, because then the index is 0 and our input_len must be at least 1, otherwise we would return -1",0.75
B,5,"If input len is negative output is not initialized, thus can contain any character.
Otherwise, when written the output is either in the range of [80, 80 + 42] or [62, + 38].",1,"input_len/2 and 0, 1, 2 mod input_len",0.5,"The call to foo is guarded by an if condition and a variable that is initialized to 0, then it is incremented on each call too foo and checked against 2. Hence foo is called a maximum 2 times per character of the input buffer.
The values it is called with are first divided by 3 and lower bounded by 60, hence in the range 60 to 255/3 and on the subsequent call the value is only divided by 2 and then checked in both directions by 60 and 150.",1,"No, the loop that runs 3 times and adjusts the bytes read from the input may add up to 0. 

In this case, the it will go into label_4 again and again.",0,"The output is either in the range [48, 48 + 73] or in the range [35, 112] with the exception of 40.
",0.75,Always exactly 8 bytes are written to the output buffer. Not depending on input_length or output length. Because of how the outer loop works.,1,"output[0] is affected by input[0] and then each byte with stride output_len.
For subsequent bytes if works the same until the output_buffer is bigger than the input_buffer then only one byte is affecting the output. Done through the modulo calculation.",1,With a one byte input buffer the fist condition in the loop is true 7 times and therefore the X will be printed 7 times. That is the maximum because the function checks for a one byte input buffer at the start.,0.75
B,6,62-80,0.1,i don't know,0,"3 Times. 60-150. Because at LABEL_3 var_5 is checked to be between those values. If not, a different path is taken.",0.75,No Time left :(,None,48-122,0.5,I don't know.,0,I don't know,0,I don't know.,0
B,7,I have no idea.,0,"I still have no idea what is going on.
",0,My time is up :-(,None,Time for this sample is exceeded :-(,None,"output[i] is set to var_5 % 256 => output[i] can be max. 255. However, if output[i] is > 100, there are various computations that make output[i] smaller. Only if it is <= 100 these computations are not executed. Hence, the valid range is [0-100].",0,I assume that L is >= 0. The number of chars written to output is independent of L. Note: I considered the number of time a char is written to output regardless of the value of i in output[i].,0.25,"output[i] depends on the loop var and is 0 only in the first iteration. The input char depends on var_6, which is 0 in the first round. If input_len is > 0 then var_6 is not modified in the first if block and is still 0 when the while loop is reached. And now I'm confused, because I think that we will get stuck in this loop... Maybe I missed sth. but my time is running out...",0.1,"First, my time is running out. Second, I unfortunately deleted the print while answering the first question and I can't remember where is was. Sorry!",None
B,8,"[g, z]",0.1,"For char 0: 0, j%input_len, 1/2 input_len
Chars: n, n%input_len, (n+j)%input_len, m % input_len, m = 1/2 input_len",0.375,"don't know, once? takes argument between (60, 150)",0.5,time is over,None,[’0’ - y],0.5,8,1,"i, i%(2*L), i%(2*L)-L
i.e. out[i] = {in[i], in[ i%(2*L)], in[i%(2*L)-L]}",0.3,"if input_len>i, i is [0, 8), dunno would go with 6, since i takes max 8 iterations,  and I assume input to take at least one character. Ok, then max = 8-input_len times",0.75
B,9,"The modulo operations on var_3 are the only relevant operations, hence the valid ASCII range depends on the char position. On even positions (0, 2, ...) the range is from 62 ('>') to 100 ('d'), inclusive, and on odd positions, the range is from 80 ('P') to 122 ('z'), inclusive.",1,"output[0] depends on input[len(input)/2], input[len(input)/2+1], input[len(input)/2+2], and input[0]. In general:

output[n] depends on input[n], input[(len(input)/2 + n) % len(input)], input[(len(input)/2 + n + 1) % len(input)] and input[(len(input)/2 + n + 2) % len(input)]",0.5,"foo is called a maximum of 3*len(input) times, since var_4 is guarding its execution. var_4 is initialized with 0. If it is changed at all, this var is incremented by one and the foo-loop is stopped when var_4 > 2. This is then looped len(input) times resulting in maximum foo calls of 3*len(input).
var_5 (the foo argument) is always in the range [0, 127] because the unsigned char can only be in [0, 255] and is at best divided by 2.",0.5,out of time,0,"Each output char can be in one of the ranges [0, 112] without {110, 111} or [48, 121] depending on the branch of var_8, leading to a final possible range of values of [0, 121].",0.5,"There are always 8 characters written to output, regardless of the input length. The outer while loop continues as long as out_i < 8. out_it is initialized with 0 and always incremented by 1 in each loop.",1,"output[0] depends on input[0] and k times input[0 + k*len(output)] as long as k*len(output) < len(input)

The general case is best described in a couple of sub-cases:

Case 1 with len(output) < len(input):
output[n] depends on input[n] and k times input[n + k*len(output)] as long as n + k*len(output) < len(input)

Case 2 with len(output) > len(input):

output[n] depends on input[n % len(input)]. Lines 14 to 19 are effectively a complicated `var_3 = in_i % input_len`

",1,"""X"" is printed when the input_len is smaller than the output_len. It is printed exactly (output_len - input_len) times.",1
B,10,I have no idea.,0,"I don't know. Obviously, input[0] can influence it and input[input_len % 2]. But I can't figure out the concrete value ranges.",0.25,"foo can be called at max 3 times due to the condition in line 30. var_4 is initially 0 and incremented in line 34 before the jump back to LABEL_3. 

Due to the checks in line 13 and 16, the argument of foo can be between 60 and 150. Although I'm not sure about 60 because of LABEL_4 and LABEL_5",0.75,"I would say no because var_5 becomes smaller and smaller with line 11 and together with  the gotos in line 24 and 28 and the if condition in line 60, this would lead to an endless loop.",0,"Considering line 54, the valid ASCII range of characters that output can contain is from 0 (48 in decimal) to y (decimal 121)",0.5,it should be at most 8 characters,0.5,I don't know,0,The maximum number of times that X is printed should be 7 due to the check in line 12 together with the do-while-loop-condition.,0.75
B,11,Output can contain ASCII Characters between 62(>) and 122(z).,1,I don't know.,0,"The Arguments can have Values from the Interval [61;150]. The reason are the two if-Statements in Line 13 and 16 which are directing the Control Flow in other directions, if var_5 is not in this Interval. Only after having checked if this is the Case, LABEL_6 is being jumped to. Var_5 is the only argument for foo. This is the only place in the Program that LABEL_5 is jumped to.
Foo is called at max 2 times, because we only jump to LABEL_3 from Line 37. The only way, in which the jump is not being executed is, if the IF-Statement in Line 30 is triggered which happens if var_4 >2. var_4 is only incremented by one in Line 34. Its initial Value is set to 0 in Line 9.",0.6,"Yes the function does always terminate. The variables deciding if we return are not influenced by the input directly, only by its length. var_1 is incremented by one for every inputcharacter. After that the function jumps to LABEL_8 and returns.",0,The maximum value that output can contain is 121 (y). The minimum Value output can contain is 1.,0.25,"After the program has returned 0, there are a total of 8 newly written characters in the output array.",1,"Output[0] is influenced by input[0] and all following Characters an the Indices x = counter + output_len * j with j in N.
So output[n] is influenced by input[n] and input[z] with z = counter + output_len * j with j in N.",0.9,"""X"" can be printed at max 7 times, bc input_len is at least 1. In every following Iteration the counter can be >= input_len (If-Statement in Line 12). Therefore the maximum amount ""X"" can be printed is 7.
""X"" is printed in Iteration x of the while-Loop, if x-1 >= input_len",0.75
