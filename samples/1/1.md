### Question 1
#### Ignoring the specific values in <em>input</em>, what is the valid ASCII value range of characters that <em>output</em> can contain after the function returned?
**Answer:**
Any character between 62 ('>') and 122 ('z') can occur. 
However, the values will fall into either the range of 62–100 or 80–122, depending on the variable `var_1`, but they do not necessarily cover the entire 62–122 span. 
More specifically, characters at even indices are between 62 and 100, while characters at odd indices are between 80 and 122.

**Points:**

- 0.1 points: correct upper bound (122)
- 0.1 points: correct lower bound (62)
- 0.4 points: identified range 62-100
- 0.4 points: identified range 80-122

We ignore obvious typos and off-by-one errors. 
Additionally, only providing the range 62-122 indicates that the participant identified both ranges.

### Question 2
#### Which <em>input</em> characters can potentially affect <em>output[0]</em>? Use this example to explain how the dependency works in general (for <em>output[n]</em>).
**Answer:**
The 0th output character depends on `input[input_len/2]`, and depending on the value of `input[input_len/2]`, it can also depend on `input[0]`, `input[1]`, and `input[2]` (each index modulo `input_len`). 
The n-th output character depends on `input[(length/2 + n) % input_len]`, and depending on the value of `input[length/2 % input_len]`, it can also depend on `input[n % input_len]`, `input[(n+1) % input_len]`, and `input[(n+2) % input_len]`.

**Points:**

- 0.125 points each for the first output character: `input[input_len/2]` and the generalization: `input[(input_len/2 + n) % input_len]`
- 0.125 points each for the first output character: `input[0]`           and the generalization: `input[n % input_len]`
- 0.125 points each for the first output character: `input[1]`           and the generalization: `input[(n+1) % input_len]`
- 0.125 points each for the first output character: `input[2]`           and the generalization: `input[(n+2) % input_len]`

If only a generalized answer is provided, we award points for the 0th and nth entries (0.25 points). 
Furthermore, we give the participant half the points if the answer is not specific and requires interpretation.

### Question 3
#### What is the maximum number of times the function <em>foo</em> is invoked during program execution? Which values can the argument of <em>foo</em> have if the function is called? Explain why.
**Answer:** 
The function `foo` is called at most `3 * input_len` times, and the variable `var_5` is between 60 and 150. 
Explanation: Before each call to `foo`, the condition `var_4 > 2` is checked; if true, the while loop terminates. After calling `foo`, the variable `var_4` is incremented. Therefore, for each iteration of the for loop, `foo` can be called up to 3 times. Since the for loop executes exactly `input_len` times, `foo` is called at most `3 * input_len` times. The range of `var_5` is determined by the while loop condition `var_5 <= 150` and the if condition `var_5 < 60`.

**Points:**

- 0.25 points for the upper bound of `var_5`: 150
- 0.25 points for the lower bound of `var_5`: 60
- 0.25 points for recognizing that `foo` is executed 3 times (correct interpretation of the break condition)
- 0.25 points for noting `3 * input_len` (it is executed for each character at most 3 times)

We ignore off-by-one errors.

### Question 4
#### Under the assumption that each character in the <em>input</em> contains only printable ASCII characters (ASCII codes 33 to 126), does the function always terminate? Explain why.
**Answer:** Yes. 
Explanation (structured sample): The if condition after the while loop is satisfied at most two times in a row: `var_3` is increased by at least `3 * 33` in the for loop, and its value is then divided by 3 to obtain the value for `var_5`. (Alternatively, `var_3` and thus `var_5` increase each time.) Consequently, at some point `var_5 >= 60`, and the if condition is no longer met, preventing further iterations of the while loop. Instead, we reach line 15. If the if condition in line 15 is not met, the variable `var_4` is incremented, which occurs at most three times before the while loop terminates. To summarize, the while loop iterates at most 12 times (2 if conditions, increasing `var_4` to 1, 2 if conditions, increasing `var_4` to 2, 2 if conditions, increasing `var_4` to 3, 2 if conditions, then breaking).

**Points:**

- 0.3 points for correctly stating that the function terminates
- 0.3 points for identifying the critical part where non-termination could occur: the while loop or the jump to `LABEL_3`
- 0.4 points for the correct explanation

We ignore alleged typos and also grant points for other correct explanations, even if they do not align with our intended ones.

---

| Complexity Scores              | A  | B  |
| ------------------------------ | -- | -- |
| Cyclomatic Complexity:         | 7  | 7  |
| Cognitive Complexity:          | 16 | 16 |
| Modified Cognitive Complexity: | 16 | 39 |
